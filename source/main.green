;;;; -*- Mode: Lisp; Syntax: ANSI-Common-Lisp; Base: 10 -*-
;;;; green-lisp - an eco-friendly lisp
;;;; Copyright (C) 2019 Moritz Hedtke <Moritz.Hedtke@t-online.de>
;;;;
;;;; This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
;;;;
;;;; This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
;;;;
;;;; You should have received a copy of the GNU Affero General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.

(require 'asdf)
(load "/home/moritz/Documents/green-lisp/source/computer-architecture/avr.green")

(defpackage :main
  (:use :common-lisp)
  (:import-from :bits :file->bit-reader :bit-writer :bit-writer->bytes :bit-writer->file)
  (:shadowing-import-from :logger :log)
  (:import-from :avr :read-instruction :write-instruction :read-any-instruction
		:+DDRB+ :+PORTB+ :+DDRC+ :+PORTC+ :+DDRE+ :+PORTE+))
(in-package :main)
#|
(defun label (label)
  (make-instance 'label :label label))

(defun rjmp (address)
  (make-instance 'rjmp :address address))

(defparameter *PROGRAM*
  (list
   (label :entry0)
   (rjmp :entry0)))

(let ((offset 0))
  (loop for element 
       (if (eq 'label (type-of element))
	   (add-label label offset))
       (setf (+ offset (size element)))))

(defmethod write-instruction ((instruction rjmp))
    (write (get-label (address instruction))))

(loop for element
     (write-instruction element))
|#



#|
(let ((o (make-instance 'bit-writer)))
  (loop repeat 35 collect
       (write-instruction :jmp o #x8c))

  ;; some general outputs
  (write-instruction :ldi o 24 #x80)
  (write-instruction :out o +DDRB+ 24) ;; TODO FIXME enforce types
  (write-instruction :out o +PORTB+ 24)

  (label :main)
  ;; red
  (write-instruction :ldi o 24 #xF0)
  (write-instruction :out o +DDRE+ 24)
  (write-instruction :out o +PORTE+ 24)

  ;; green
  (write-instruction :ldi o 24 #x0F)
  (write-instruction :out o +DDRC+ 24)
  (write-instruction :out o +PORTC+ 24)

  ;; defun delay
  ;; constant numbers
  (write-instruction :ldi o 20 #x00)
  (write-instruction :ldi o 21 #x01)
  
  (write-instruction :ldi o 22 #x00)
  (write-instruction :ldi o 23 #x00)
  (write-instruction :ldi o 24 #x00)
  
  (label :target1)
  (write-instruction :adc o 22 21)
  (write-instruction :adc o 23 20)
  (write-instruction :adc o 24 20)
  (write-instruction :brcc o :target1) ;; :target

  ;; red
  (write-instruction :ldi o 24 #x0F)
  (write-instruction :out o +DDRE+ 24)
  (write-instruction :out o +PORTE+ 24)

  ;; green
  (write-instruction :ldi o 24 #xF0)
  (write-instruction :out o +DDRC+ 24)
  (write-instruction :out o +PORTC+ 24)  


  ;; defun delay
  ;; constant numbers
  (write-instruction :ldi o 20 #x00)
  (write-instruction :ldi o 21 #x01)
  
  (write-instruction :ldi o 22 #x00)
  (write-instruction :ldi o 23 #x00)
  (write-instruction :ldi o 24 #x00)

  (label :target2)
  (write-instruction :adc o 22 21)
  (write-instruction :adc o 23 20)
  (write-instruction :adc o 24 20)
  (write-instruction :brcc o :target2)

  (write-instruction :rjmp o :main)
  
  (bit-writer->file o "test.bin"))

;;(let ((i (file->bit-reader #P"/home/moritz/Documents/green-lisp/binary.bin")))
;;  (loop repeat 30 do (read-any-instruction i)))

(uiop:run-program "avr-objcopy -I binary -O ihex test.bin test.ihex && avrdude -c stk500v2 -P /dev/ttyACM0 -p atmega128 -B 2 -U flash:w:test.ihex" :output *standard-output* :force-shell t :error-output *standard-output*)
|#
