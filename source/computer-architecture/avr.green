;;;; -*- Mode: Lisp; Syntax: ANSI-Common-Lisp; Base: 10 -*-
;;;; green-lisp - an eco-friendly lisp
;;;; Copyright (C) 2019 Moritz Hedtke <Moritz.Hedtke@t-online.de>
;;;;
;;;; This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
;;;;
;;;; This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
;;;;
;;;; You should have received a copy of the GNU Affero General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.

; atmega128 http://ww1.microchip.com/downloads/en/DeviceDoc/doc2467.pdf
; https://www.microchip.com/webdoc/avrassembler/avrassembler.wb_instruction_list.html

(load "/home/moritz/Documents/green-lisp/source/logger.green")
(load "/home/moritz/Documents/green-lisp/source/bits.green")

(defpackage :avr
  (:use :common-lisp)
  (:import-from :bits :bit-reader :bit-reader-bits :read-bit :file->bit-reader :bit-writer :write-bit :bit-writer->bytes)
  (:import-from :logger :+trace+ :+debug+ :+info+ :+warning+ :+error+)
  (:shadowing-import-from :logger :log)
  (:export :read-instruction :write-instruction :read-any-instruction
	   :+DDRB+ :+PORTB+ :+DDRE+ :+PORTE+ :+DDRC+ :+PORTC+

	   :instruction-size
	   
	   :label :jmp :ldi :out :rjmp :brcc :adc

	   ))
(in-package :avr)

(defmacro read-format (instruction format &body body)
  (let ((name (car instruction))
	(args (mapcar #'car (cdr instruction))))
    `(progn (defmethod read-instruction ((name (eql ',name)) (bit-reader bit-reader)) 
	      (let ,(mapcar (lambda (s) `(,s 0)) args)
		,@(loop for item in format collect
		       (cond ((or (eql item 0) (eql item 1))
			      `(let ((bit (read-bit bit-reader)))
				 (log +trace+ (format nil "readi ~a" bit))
				 (unless (= ,item bit)
				   (log +trace+ (format nil "fail-not-a-~a" ,item))
				   (return-from read-instruction nil))))
			     (t
			      `(let ((bit (read-bit bit-reader)))
				 (log +trace+ (format nil "read ~a" bit))
				 (setf ,item (logior (ash ,item 1) bit))))))
		,@(mapcar
		   (lambda (item)
		     `(setf ,(nth 0 item) ,(nth 2 item)))
		   (cdr instruction))
		,@body
		t))
	    )
    ))

(defmacro write-format (instruction format)
  (let ((name (car instruction))
	(args (mapcar #'car (cdr instruction))))
    `(progn
       ;; TODO hash-map?
       (defmethod instruction-size ((name (eql ',name)))
	 ,(/ (length format) 8))
       
       (defmethod ,name ((bit-writer bit-writer) ,@args)
	      ,@(mapcar
		 (lambda (item)
		   `(setf ,(nth 0 item) ,(nth 3 item)))
		 (cdr instruction))
	      ,@(maplist
		 (lambda (item-list)
		   (let ((item (car item-list)))
		     (cond ((or (eql item 0) (eql item 1))
			    `(progn
			       (write-bit bit-writer ,item)
			       (log +trace+ (format nil "writei ~a" ,item))))
			   (t
			    `(let* ((index ,(- (count-if (lambda (i) (eql i item)) item-list) 1))
				    (bit (if (logbitp index ,item) 1 0)))
			       (log +trace+ (format nil "write ~a" bit))
			       (write-bit bit-writer bit))))))
		 format)
	      (bit-writer->bytes bit-writer))
	    (defmethod write-instruction ((name (eql ',name)) &rest parameters)
		(apply ',name parameters)))))

(defmacro define-assembly-instruction (instruction instruction-format cycles &body body)
  (declare (ignore cycles))
  `(progn
     (write-format ,instruction ,instruction-format)
     (read-format ,instruction ,instruction-format ,@body)
     (lambda (bit-reader)
       (read-instruction ',(car instruction) bit-reader))))

(defgeneric read-instruction (name binary-reader)
  (:documentation "Reads the instruction of the specified type from the binary reader."))

;; https://www.microchip.com/webdoc/avrassembler/avrassembler.wb_JMP.html

(defparameter +all-instructions+
  (list

   (define-assembly-instruction (adc (d register d d (and (<= 0 d) (<= d 31))) (r register r r (and (<= 0 r) (<= r 31))))
       (0 0 0 1 1 1 r d  d d d d r r r r)
       1
     (log +debug+ (format nil "adc r~d, r~d~%" d r)))

   (define-assembly-instruction (add (d register d d (and (<= 0 d) (<= d 31))) (r register r r (and (<= 0 r) (<= r 31))))
       (0 0 0 0 1 1 r d  d d d d r r r r)
       1
     (log +debug+ (format nil "add r~d, r~d~%" d r)))

   (define-assembly-instruction (adiw (d register-pair d d (or (= d 24) (= d 26) (= d 28) (= d 30))) (k constant k k (and (<= 0 k) (<= k 63))))
       (1 0 0 1 0 1 1 0  k k d d k k k k)
       2
     (log +debug+ (format nil "adiw r~d, 0x~x~%" d k)))

   (define-assembly-instruction (_and (d register d d (<= 0 d) (<= d 31)) (r register r r (and (<= 0 r) (<= r 31))))
       (0 0 1 0 0 0 r d  d d d d r r r r)
       1
     (log +debug+ (format nil "and r~d, r~d~%" d r)))

   (define-assembly-instruction (andi (d register d d (and (<= 0 d) (<= d 31))) (k constant k k (and (<= 0 k) (<= k 255))))
       (0 1 1 1 k k k k  d d d d k k k k)
       1
     (log +debug+ (format nil "andi r~d, 0x~x~%" d k)))

   (define-assembly-instruction (asr (d register d d (and (<= 0 d) (<= d 31))))
       (1 0 0 1 0 1 0 d  d d d d 0 1 0 1)
       1
     (log +debug+ (format nil "asr r~d~%" d)))

   (define-assembly-instruction (bclr (s bit s s (and (<= 0 s) (<= s 7))))
       (1 0 0 1 0 1 0 0  1 s s s 1 0 0 0)
       1
     (log +debug+ (format nil "bclr ~d~%" s)))

   (define-assembly-instruction (bld (d register d d (and (<= 0 d) (<= d 31))) (b bit b b (and (<= 0 b) (<= b 7))))
       (1 1 1 1 1 0 0 d  d d d d 0 b b b b)
       1
     (log +debug+ (format nil "bld r~d, ~d~%" d b)))
   
   ;; https://www.microchip.com/webdoc/avrassembler/avrassembler.wb_BRBC.html
   (define-assembly-instruction (brbc (s bit s s (and (<= 0 s) (<= s 7)))
				      (k address (ash k 1) (ash k -1) (and (<= -64 k) (<= k 63))))
       (1 1 1 1 0 1 k k  k k k k k s s s)
       (if (= 0 (getf (sreg s))) 2 1)
     (log +debug+ (format nil "brbc ~d, 0x~x~%" s k)))

   ;; https://www.microchip.com/webdoc/avrassembler/avrassembler.wb_BRBS.html
   (define-assembly-instruction (brbs (s bit s s (and (<= 0 s) (<= s 7)))
				      (k address (ash k 1) (ash k -1) (and (<= -64 k) (<= k 63))))
       (1 1 1 1 0 0 k k  k k k k k s s s)
       (if (= 1 (getf (sreg s))) 2 1)
     (log +debug+ (format nil "brbs ~d, 0x~x~%" s k)))

   ;; https://www.microchip.com/webdoc/avrassembler/avrassembler.wb_BRCC.html
   (defmacro brcc (k)
     `(brbc 0 ,k))

   ;; https://www.microchip.com/webdoc/avrassembler/avrassembler.wb_BRCS.html
   (defmacro brcs (k)
     `(brbs 0 ,k))

   (define-assembly-instruction (_break)
       (1 0 0 1 0 1 0 1  1 0 0 1 1 0 0 0)
       1
     (log +debug+ (format nil "break~%")))

   (defmacro breq (k)
     `(brbs 1 ,k))

   ;; https://www.microchip.com/webdoc/avrassembler/avrassembler.wb_BRGE.html
   (defmacro brge (k)
     `(brbc 4 ,k))

   ;; https://www.microchip.com/webdoc/avrassembler/avrassembler.wb_BRHC.html
   (defmacro brhc (k)
     `(brbc 5 ,k))

   ;; https://www.microchip.com/webdoc/avrassembler/avrassembler.wb_BRHS.html
   (defmacro brhs (k)
     `(brbs 5 ,k))

   ;; https://www.microchip.com/webdoc/avrassembler/avrassembler.wb_BRID.html
   (defmacro brid (k)
     `(brbc 7 ,k))

   ;; https://www.microchip.com/webdoc/avrassembler/avrassembler.wb_BRIE.html
   (defmacro brie (k)
     `(brbs 7 ,k))

   ;; https://www.microchip.com/webdoc/avrassembler/avrassembler.wb_BRLO.html
   (defmacro brlo (k)
     `(brbs 0 ,k))

   ;; https://www.microchip.com/webdoc/avrassembler/avrassembler.wb_BRLT.html
   (defmacro brlt (k)
     `(brbs 4 ,k))

   ;; https://www.microchip.com/webdoc/avrassembler/avrassembler.wb_BRMI.html
   (defmacro brmi (k)
     `(brbs 2 ,k))

   ;; https://www.microchip.com/webdoc/avrassembler/avrassembler.wb_BRNE.html
   (defmacro brne (k)
     `(brbc 1 ,k))

   ;; https://www.microchip.com/webdoc/avrassembler/avrassembler.wb_BRPL.html
   (defmacro brpl (k)
     `(brbc 2 ,k))

   ;; https://www.microchip.com/webdoc/avrassembler/avrassembler.wb_BRSH.html
   (defmacro brsh (k)
     `(brbc 0 ,k))

   ;; https://www.microchip.com/webdoc/avrassembler/avrassembler.wb_BRTC.html
   (defmacro brtc (k)
     `(brbc 6 ,k))

   ;; https://www.microchip.com/webdoc/avrassembler/avrassembler.wb_BRTS.html
   (defmacro brts (k)
     `(brbs 6 ,k))

   ;; https://www.microchip.com/webdoc/avrassembler/avrassembler.wb_BRVC.html
   (defmacro brvc (k)
     `(brbc 3 ,k))

   ;; https://www.microchip.com/webdoc/avrassembler/avrassembler.wb_BRVS.html
   (defmacro brvs (k)
     `(brbs 3 ,k))

   ;; https://www.microchip.com/webdoc/avrassembler/avrassembler.wb_BSET.html
   (define-assembly-instruction (bset (s bit s s (and (<= 0 s) (<= s 7))))
       (1 0 0 1 0 1 0 0  0 s s s 1 0 0 0)
       1
     (log +debug+ (format nil "bset ~d~%" s)))

   ;; https://www.microchip.com/webdoc/avrassembler/avrassembler.wb_BST.html
   (define-assembly-instruction (bst (d register d d (and (<= 0 d) (<= d 31)))
				     (b bit b b (and (<= 0 b) (<= b 7))))
       (1 1 1 1 1 0 1 d  d d d d 0 b b b)
       1
     (log +debug+ (format nil "bst r~d, ~d~%" d b)))

   (define-assembly-instruction (call (k address (ash k 1) (ash k -1) (and (<= 0 k) (<= k 64000))))
       (1 0 0 1 0 1 0 k  k k k k 1 1 1 k  k k k k k k k k  k k k k k k k k)
       4 ;; TODO FIXME THIS IS ONLY CORRECT FOR ATMEGA128
     (log +debug+ (format nil "call 0x~x~%" k)))

   ;; https://www.microchip.com/webdoc/avrassembler/avrassembler.wb_CBI.html
   (define-assembly-instruction (cbi (a io-register a a (and (<= 0 a) (<= a 31)))
				     (b bit b b (and (<= 0 b) (<= b 7))))
       (1 0 0 1 1 0 0 0  a a a a a b b b)
       2 ;; FIXME this can be different
     (log +debug+ (format nil "cbi ~d, ~d~%" a b)))

   ;; https://www.microchip.com/webdoc/avrassembler/avrassembler.wb_CBR.html
   ;; TODO ANDI

   ;; https://www.microchip.com/webdoc/avrassembler/avrassembler.wb_CLC.html
   (defmacro clc ()
     `(bclr 0))

   ;; https://www.microchip.com/webdoc/avrassembler/avrassembler.wb_CLH.html
   (defmacro clh ()
     `(bclr 5))

   ;; https://www.microchip.com/webdoc/avrassembler/avrassembler.wb_CLI.html
   (defmacro cli ()
     `(bclr 7))

   ;; https://www.microchip.com/webdoc/avrassembler/avrassembler.wb_CLN.html
   (defmacro cln ()
     `(bclr 2))

   ;; https://www.microchip.com/webdoc/avrassembler/avrassembler.wb_CLR.html
   ;; TODO EOR Rd, Rd

   ;; https://www.microchip.com/webdoc/avrassembler/avrassembler.wb_CLS.html
   (defmacro cls ()
     `(bclr 4))

   ;; https://www.microchip.com/webdoc/avrassembler/avrassembler.wb_CLT.html
   (defmacro clt ()
     `(bclr 6))

   ;; https://www.microchip.com/webdoc/avrassembler/avrassembler.wb_CLV.html
   (defmacro clv ()
     `(bclr 3))

   ;; https://www.microchip.com/webdoc/avrassembler/avrassembler.wb_CLZ.html
   (defmacro clz ()
     `(bclr 1))

   ;; https://www.microchip.com/webdoc/avrassembler/avrassembler.wb_COM.html
   (define-assembly-instruction (com (d register d d (and (<= 0 d) (<= d 31))))
       (1 0 0 1 0 1 0 d  d d d d 0 0 0 0)
       1
     (log +debug+ (format nil "com r~d~%" d)))

   ;; https://www.microchip.com/webdoc/avrassembler/avrassembler.wb_CP.html
   (define-assembly-instruction (cp (d register d d (and (<= 0 d) (<= d 31)))
				    (r register r r (and (<= 0 r) (<= r 31))))
       (0 0 0 1 0 1 r d  d d d d r r r r)
       1
     (log +debug+ (format nil "cp r~d, r~d~%" d r)))

   ;; https://www.microchip.com/webdoc/avrassembler/avrassembler.wb_CPC.html
   (define-assembly-instruction (cpc (d register d d (and (<= 0 d) (<= d 31)))
				     (r register r r (and (<= 0 r) (<= r 31))))
       (0 0 0 0 0 1 r d  d d d d r r r r)
       1
     (log +debug+ (format nil "cpc r~d, r~d~%" d r)))

   ;; https://www.microchip.com/webdoc/avrassembler/avrassembler.wb_CPI.html
   (define-assembly-instruction (cpi (d register d d (and (<= 16 #| TODO FIXME |# d) (<= d 31)))
				     (k constant k k (and (<= 0 k) (<= k 255))))
       (0 0 1 1 k k k k d d d d k k k k)
       1
     (log +debug+ (format nil "cpi r~d, 0x~x~%" d k)))

   ;; https://www.microchip.com/webdoc/avrassembler/avrassembler.wb_CPSE.html
   (define-assembly-instruction (cpse (d register d d (and (<= 0 d) (<= d 31)))
				      (r register r r (and (<= 0 r) (<= r 31))))
       (0 0 0 1 0 0 r d  d d d d r r r r)
       bruh ;; TODO
     (log +debug+ (format nil "cpse r~d, r~d~%" d r)))

   ;; https://www.microchip.com/webdoc/avrassembler/avrassembler.wb_DEC.html
   (define-assembly-instruction (dec (d register d d (and (<= 0 d) (<= d 31))))
       (1 0 0 1 0 1 0 d  d d d d 1 0 1 0)
       1
     (log +debug+ (format nil "dec r~d~%" d)))

   ;; https://www.microchip.com/webdoc/avrassembler/avrassembler.wb_EICALL.html
   (define-assembly-instruction (eicall)
       (1 0 0 1 0 1 0 1  0 0 0 1 1 0 0 1)
       4
     (log +debug+ (format nil "eicall~%")))

   ;; https://www.microchip.com/webdoc/avrassembler/avrassembler.wb_EIJMP.html
   (define-assembly-instruction (eijmp)
       (1 0 0 1 0 1 0 0  0 0 0 1 1 0 0 1)
       2
     (log +debug+ (format nil "eijmp~%")))

   ;; https://www.microchip.com/webdoc/avrassembler/avrassembler.wb_ELPM.html
   ;; FIXME The result of these combinations is undefined:
   (define-assembly-instruction (elpm0)
       (1 0 0 1 0 1 0 1  1 1 0 1 1 0 0 0)
       3
     (log +debug+ (format nil "elpm~%")))

   ;; https://www.microchip.com/webdoc/avrassembler/avrassembler.wb_ELPM.html
   (define-assembly-instruction (elpm (d register d d (and (<= 0 d) (<= d 31))))
       (1 0 0 1 0 0 0 d  d d d d 0 1 1 0)
       3
     (log +debug+ (format nil "elpm r~d~%" d)))
   
   ;; https://www.microchip.com/webdoc/avrassembler/avrassembler.wb_ELPM.html
   (define-assembly-instruction (elpm+ (d register d d (and (<= 0 d) (<= d 31))))
       (1 0 0 1 0 0 0 d  d d d d 0 1 1 1)
     3
     (log +debug+ (format nil "elpm+ r~d~%" d)))

   ;; https://www.microchip.com/webdoc/avrassembler/avrassembler.wb_EOR.html
   (define-assembly-instruction (eor (d register d d (and (<= 0 d) (<= d 31)))
				     (r register r r (and (<= 0 r) (<= r 31))))
       (0 0 1 0 0 1 r d  d d d d r r r r)
       1
     (log +debug+ (format nil "eor r~d, r~d~%" d r)))

   ;; https://www.microchip.com/webdoc/avrassembler/avrassembler.wb_FMUL.html
   (define-assembly-instruction (fmul (d register (+ d 16) (- d 16) (and (<= 16 d) (<= d 23)))
				      (r register (+ r 16) (- r 16) (and (<= 16 r) (<= r 23))))
       (0 0 0 0 0 0 1 1  0 d d d 1 r r r)
       2
     (log +debug+ (format nil "fmul r~d, r~d~%" d r)))

   ;; https://www.microchip.com/webdoc/avrassembler/avrassembler.wb_FMULS.html
   (define-assembly-instruction (fmuls (d register (+ d 16) (- d 16) (and (<= 16 d) (<= d 23)))
				       (r register (+ r 16) (- r 16) (and (<= 16 r) (<= r 23))))
       (0 0 0 0 0 0 1 1  1 d d d 0 r r r)
       2
     (log +debug+ (format nil "fmuls r~d, r~d~%" d r)))

   ;; https://www.microchip.com/webdoc/avrassembler/avrassembler.wb_FMULSU.html
   (define-assembly-instruction (fmulsu (d register (+ d 16) (- d 16) (and (<= 16 d) (<= d 23)))
				       (r register (+ r 16) (- r 16) (and (<= 16 r) (<= r 23))))
       (0 0 0 0 0 0 1 1  1 d d d 1 r r r)
       2
     (log +debug+ (format nil "fmulsu r~d, r~d~%" d r)))

   ;; https://www.microchip.com/webdoc/avrassembler/avrassembler.wb_ICALL.html
   (define-assembly-instruction (icall)
       (1 0 0 1 0 1 0 1 0 0 0 0 1 0 0 1)
       3 ;; TODO FIXME
     (log +debug+ (format nil "icall~%")))

   ;; https://www.microchip.com/webdoc/avrassembler/avrassembler.wb_IJMP.html
   (define-assembly-instruction (ijmp)
       (1 0 0 1 0 1 0 0  0 0 0 0 1 0 0 1)
       2
     (log +debug+ (format nil "ijmp~%")))

   ;; https://www.microchip.com/webdoc/avrassembler/avrassembler.wb_IN.html
   (define-assembly-instruction (in (d register d d (and (<= 0 d) (<= d 31)))
				    (a io-register a a (and (<= 0 a) (<= a 64))))
       (1 0 1 1 0 a a d  d d d d a a a a)
       1
     (log +debug+ (format nil "in r~d, 0x~x~%" d a)))

   ;; https://www.microchip.com/webdoc/avrassembler/avrassembler.wb_INC.html
   (define-assembly-instruction (inc (d register d d (and (<= 0 d) (<= d 31))))
       (1 0 0 1 0 1 0 d  d d d d 0 0 1 1)
       1
     (log +debug+ (format nil "inc r~d~%" d)))

   ;; https://www.microchip.com/webdoc/avrassembler/avrassembler.wb_JMP.html
   (define-assembly-instruction (jmp (k address (ash k 1) (ash k -1) (and (<= 0 k) (< k 4000000))))
       (1 0 0 1 0 1 0 k  k k k k 1 1 0 k  k k k k k k k k  k k k k k k k k)
       3 ;; cycles
     ;;(setf program-counter k))
     (log +debug+ (format nil "jmp 0x~x~%" k)))

   ;; https://www.microchip.com/webdoc/avrassembler/avrassembler.wb_LD.html
   ;; The result of these combinations is undefined:
   (define-assembly-instruction (ld (d register d d (and (<= 0 d) (<= d 31))))
       (1 0 0 1 0 0 0 d  d d d d 1 1 0 0)
       2 ;; TODO FIXME
     (log +debug+ (format nil "ld r~d, X" d)))

   ;; https://www.microchip.com/webdoc/avrassembler/avrassembler.wb_LD.html
   ;; The result of these combinations is undefined:
   (define-assembly-instruction (ld+ (d register d d (and (<= 0 d) (<= d 31))))
       (1 0 0 1 0 0 0 d  d d d d 1 1 0 1)
       2 ;; TODO FIXME
     (log +debug+ (format nil "ld r~d, X+" d)))

   ;; https://www.microchip.com/webdoc/avrassembler/avrassembler.wb_LD.html
   ;; The result of these combinations is undefined:
   (define-assembly-instruction (ld- (d register d d (and (<= 0 d) (<= d 31))))
       (1 0 0 1 0 0 0 d  d d d d 1 1 1 0)
       2 ;; TODO FIXME
     (log +debug+ (format nil "ld r~d, -X" d)))

   ;; https://www.microchip.com/webdoc/avrassembler/avrassembler.wb_LAT.html
   (define-assembly-instruction (lat (r register r r (and (<= 0 r) (<= r 31))))
       (1 0 0 1 0 0 0 r  r r r r 0 1 1 1)
       2
     (log +debug+ (format nil "lat r~d~%" r)))

   ;; https://www.microchip.com/webdoc/avrassembler/avrassembler.wb_LAS.html
   (define-assembly-instruction (las (r register r r (and (<= 0 r) (<= r 31))))
       (1 0 0 1 0 0 0 r  r r r r 0 1 0 1)
       2
     (log +debug+ (format nil "las r~d~%" r)))

   ;; https://www.microchip.com/webdoc/avrassembler/avrassembler.wb_LAC.html
   (define-assembly-instruction (lac (r register r r (and (<= 0 r) (<= r 31))))
       (1 0 0 1 0 0 0 r  r r r r 0 1 1 0)
       2
     (log +debug+ (format nil "lac r~d~%" r)))
   
   ;; https://www.microchip.com/webdoc/avrassembler/avrassembler.wb_LDD.html
   ;; The result of these combinations is undefined:
   (define-assembly-instruction (ldy (d register d d (and (<= 0 d) (<= d 31))))
       (1 0 0 0 0 0 0 d  d d d d 1 0 0 0)
       2 ;; TODO FIXME
     (log +debug+ (format nil "ld r~d, Y" d)))

   ;; https://www.microchip.com/webdoc/avrassembler/avrassembler.wb_LDD.html
   ;; The result of these combinations is undefined:
   (define-assembly-instruction (ldy+ (d register d d (and (<= 0 d) (<= d 31))))
       (1 0 0 1 0 0 0 d  d d d d 1 0 0 1)
       2 ;; TODO FIXME
     (log +debug+ (format nil "ld r~d, Y+" d)))

   ;; https://www.microchip.com/webdoc/avrassembler/avrassembler.wb_LDD.html
   ;; The result of these combinations is undefined:
   (define-assembly-instruction (ld-y (d register d d (and (<= 0 d) (<= d 31))))
       (1 0 0 1 0 0 0 d  d d d d 1 0 1 0)
       2 ;; TODO FIXME
     (log +debug+ (format nil "ld r~d, -Y" d)))

   ;; https://www.microchip.com/webdoc/avrassembler/avrassembler.wb_LDD.html
   ;; The result of these combinations is undefined:
   (define-assembly-instruction (lddy (d register d d (and (<= 0 d) (<= d 31))))
       (1 0 0 1 0 0 0 d  d d d d 1 0 1 0)
       2 ;; TODO FIXME
     (log +debug+ (format nil "ld r~d, -Y" d)))

   
   
   (define-assembly-instruction (ldi (d register (+ d 16) (- d 16) (and (<= 16 d) (<= d 31))) (k io-address k k (and (<= 0 k) (<= k 255))))
       (1 1 1 0 k k k k  d d d d k k k k)
       1
     ;;(setf (register d) k)
     ;;(setf program-counter (+ program-counter 2)))
     (log +debug+ (format nil "ldi r~d, 0x~x~%" d k)))
   
   ;; out
   (define-assembly-instruction (out (a port a a (and (<= 0 a) (<= a 64))) (r register r r (and (<= 0 r) (<= r 31))))
       (1 0 1 1 1 a a r  r r r r a a a a)
     1
     ;; (out a r)
     ;; (setf program-counter (+ program-counter 2))
     (log +debug+ (format nil "out 0x~x, r~d~%" a r)))
   
   ;; rjmp
   (define-assembly-instruction (rjmp (k address (ash k 1) (ash k -1) (and (<= -2048 k) (<= k 2048))))
       (1 1 0 0 k k k k  k k k k k k k k)
     2
     (log +debug+ (format nil "rjmp 0x~x~%" k)))

   
   ))

(defun read-any-instruction (bit-reader)
  (loop for method in +all-instructions+ do
       (let* ((new-bit-reader (make-instance 'bit-reader :bits (bit-reader-bits bit-reader)))
	     (result (funcall method new-bit-reader)))
	 (if result
	     (return-from read-any-instruction new-bit-reader)))))

(defparameter +DDRB+ #x17) ; #x37
(defparameter +PORTB+ #x18) ; #x38
(defparameter +DDRE+ #x02) ; #x22
(defparameter +PORTE+ #x03) ; #x23
(defparameter +DDRC+ #x14) ; #x34
(defparameter +PORTC+ #x15) ; #x35

#|

(define-pin 21 vcc)
(define-pin 22 ground)
(define-pin 47 (port a 4))
(define-pin 48 (port a 3))
(define-pin 49 (port a 2))
(define-pin 50 (port a 1))
(define-pin 51 (port a 0))
; ... page 5

; 32 registers
(define-register (status-register 7) global-interrupt-enable)
(define-register (status-register 6) bit-copy-storage)
(define-register (status-register 5) half-carry-flag)
(define-register (status-register 4) sign-bit)
(define-register (status-register 3) twos-complement-overflow-flag)
(define-register (status-register 2) negative-flag)
(define-register (status-register 1) zero-flag)
(define-register (status-register 0) carry-flag)
(define-register (register #x00 r0))
(define-register (register #x01 r1))
(define-register (register #x02 r2))
; ... X Y Z register
(define-register (stack-pointer sph))
(define-register (stack-pointer spl))

;; RAMPZ

(define-flash 128000)

(define-eeprom 4096)
;; EEARH EEARL EEDR EECR

(define-sram 4096)

(define-external-sram)

(define-memory-locations (registers 32) (io-memory 64) (extended-io-memory 160) (internal-data-sram 4096))

(define-real-time-counter ) ;

(define-timers ) ; TODO page 35

(define-usarts ); 

(define-two-wire-serial-interface ) ;

(define-analog-digital-converter ) ;

(define-watchdog-timer ) ;

(define-spi-serial-port ) ;

(define-jtag-interface ) ; page 48

(define-sleep-modes (idle power-down power-save adc-noise-reduction standby extended-standby)) ;; TODO page 44

(define-reset) ; page 49

(define-qtouch-library ) ;;

 ;; page 59
(define-interrupt-vector #x0000 reset)
(define-interrupt-vector #x0002 int0)

(define-interrupt-vectors
    (reset
     external-interrupt-0
     external-interrupt-1
     external-interrupt-2
     external-interrupt-3
     external-interrupt-4
     external-interrupt-5
     external-interrupt-6
     external-interrupt-7
     timer-2-compare-match
     timer-2-overflow
     timer-1-capture-event
     timer-1-compare-match-a
     timer-1-compare-match-b
     timer-1-overflow
     timer-0-compare-match
     timer-0-overflow
     serial-transfer-complete
     usart-0-receive-complete
     usart-0-data-register-empty
     usart-0-transfer-complete
     adc-conversion-complete
     eeprom-ready
     analog-comparator
     timer-1-compare-match-c
    ;; ...


;; external interrupts page 89

;; a-bit timer with pwm and asynchronous operation page 92

;; output compare modulator page 160

;; serial peripheral interface p 162

;; usart page 170

;; two-wire serial interface page 197

;; analog comparator page 227

;; analog to digital converter page 230

;; jtag interface and on-chip debug system page 246

;; boot loader support - read-while-write self-programming page 273

;; parallel programming page 290

|#
