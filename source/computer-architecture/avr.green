;;;; -*- Mode: Lisp; Syntax: ANSI-Common-Lisp; Base: 10 -*-
; atmega128 http://ww1.microchip.com/downloads/en/DeviceDoc/doc2467.pdf
; https://www.microchip.com/webdoc/avrassembler/avrassembler.wb_instruction_list.html

(load "/home/moritz/Documents/green-lisp/source/logger.green")
(load "/home/moritz/Documents/green-lisp/source/bits.green")

(defpackage :avr
  (:use :common-lisp)
  (:import-from :bits :bit-reader :bit-reader-bits :read-bit :file->bit-reader :bit-writer :write-bit :bit-writer->bytes)
  (:import-from :logger :+trace+ :+debug+ :+info+ :+warning+ :+error+)
  (:shadowing-import-from :logger :log)
  (:export :read-instruction :write-instruction :read-any-instruction
	   :+DDRB+ :+PORTB+ :+DDRE+ :+PORTE+))
(in-package :avr)

(defmacro read-format (instruction format &body body)
  (let ((name (car instruction))
	(args (mapcar #'car (cdr instruction))))
    `(defmethod read-instruction ((name (eql ',name)) (bit-reader bit-reader)) 
       (let ,(mapcar (lambda (s) `(,s 0)) args)
	 ,@(loop for item in format collect
		      (cond ((or (eql item 0) (eql item 1))
			     `(let ((bit (read-bit bit-reader)))
				(log +trace+ (format nil "readi ~a" bit))
				(unless (= ,item bit)
				  (log +trace+ (format nil "fail-not-a-~a" ,item))
				  (return-from read-instruction nil))))
			    (t
			     `(let ((bit (read-bit bit-reader)))
				(log +trace+ (format nil "read ~a" bit))
				(setf ,item (logior (ash ,item 1) bit))))))
	 ,@body
	 t))))

(defgeneric write-instruction (name bit-writer &rest vars)
  (:documentation "Write the specified instruction to the bit-writer."))

(defmacro write-format (instruction format)
  (let ((name (car instruction))
	(args (mapcar #'car (cdr instruction))))
    `(defmethod write-instruction ((name (eql ',name)) (bit-writer bit-writer) &rest parameters)
       (destructuring-bind ,args parameters
	 ,@(maplist
	    (lambda (item-list)
	      (let ((item (car item-list)))
		(cond ((or (eql item 0) (eql item 1))
		       `(progn
			  (write-bit bit-writer ,item)
			  (log +trace+ (format nil "writei ~a" ,item))))
		      (t
		       `(let* ((index ,(- (count-if (lambda (i) (eql i item)) item-list) 1))
			       (bit (if (logbitp index ,item) 1 0)))
			  (log +trace+ (format nil "write ~a" bit))
			  (write-bit bit-writer bit))))))
	    format))
       (bit-writer->bytes bit-writer))))

(defmacro define-assembly-instruction (instruction instruction-format cycles &body body)
  (declare (ignore cycles))
  `(progn
     (write-format ,instruction ,instruction-format)
     (read-format ,instruction ,instruction-format ,@body)
     (lambda (bit-reader)
       (read-instruction ,(car instruction) bit-reader))))

(defgeneric read-instruction (name binary-reader)
  (:documentation "Reads the instruction of the specified type from the binary reader."))

;; https://www.microchip.com/webdoc/avrassembler/avrassembler.wb_JMP.html

(defparameter +all-instructions+
  (list
   (define-assembly-instruction (:jmp (k address (ash k 1) (ash k -1) (and (<= 0 k) (< k 4000000))))
       (1 0 0 1 0 1 0 k  k k k k 1 1 0 k  k k k k k k k k  k k k k k k k k)
       3 ;; cycles
     ;;(setf program-counter k))
     (log +debug+ (format nil "jmp 0x~x~%" (ash k 1))))

    (define-assembly-instruction (:ldi (d register (+ d 16) (- d 16) (and (<= 16 d) (<= d 31))) (k io-address k k (and (<= 0 k) (<= k 255))))
       (1 1 1 0 k k k k  d d d d k k k k)
	1
      ;;(setf (register d) k)
      ;;(setf program-counter (+ program-counter 2)))
      (log +debug+ (format nil "ldi r~d, 0x~x~%" d k)))

    ;; eor

    ;; out
    (define-assembly-instruction (:out (a port a a (and (<= 0 a) (<= a 64))) (r register r r (and (<= 0 r) (<= r 31))))
	(1 0 1 1 1 a a r  r r r r a a a a)
	1
      ;; (out a r)
      ;; (setf program-counter (+ program-counter 2))
      (log +debug+ (format nil "out 0x~x, r~d~%" a r)))

    ;; rjmp

    ;; st

    ;; cpi

    ;; cpc

    ;; brne

    ;; call


    ))

(defun read-any-instruction (bit-reader)
  (loop for method in +all-instructions+ do
       (let* ((new-bit-reader (make-instance 'bit-reader :bits (bit-reader-bits bit-reader)))
	     (result (funcall method new-bit-reader)))
	 (if result
	     (return-from read-any-instruction new-bit-reader)))))

(defparameter +DDRB+ #x17) ; #x37
(defparameter +PORTB+ #x18) ; #x38
(defparameter +DDRE+ #x02) ; #x22
(defparameter +PORTE+ #x03) ; #x23

#|

(define-pin 21 vcc)
(define-pin 22 ground)
(define-pin 47 (port a 4))
(define-pin 48 (port a 3))
(define-pin 49 (port a 2))
(define-pin 50 (port a 1))
(define-pin 51 (port a 0))
; ... page 5

; 32 registers
(define-register (status-register 7) global-interrupt-enable)
(define-register (status-register 6) bit-copy-storage)
(define-register (status-register 5) half-carry-flag)
(define-register (status-register 4) sign-bit)
(define-register (status-register 3) twos-complement-overflow-flag)
(define-register (status-register 2) negative-flag)
(define-register (status-register 1) zero-flag)
(define-register (status-register 0) carry-flag)
(define-register (register #x00 r0))
(define-register (register #x01 r1))
(define-register (register #x02 r2))
; ... X Y Z register
(define-register (stack-pointer sph))
(define-register (stack-pointer spl))

;; RAMPZ

(define-flash 128000)

(define-eeprom 4096)
;; EEARH EEARL EEDR EECR

(define-sram 4096)

(define-external-sram)

(define-memory-locations (registers 32) (io-memory 64) (extended-io-memory 160) (internal-data-sram 4096))

(define-real-time-counter ) ;

(define-timers ) ; TODO page 35

(define-usarts ); 

(define-two-wire-serial-interface ) ;

(define-analog-digital-converter ) ;

(define-watchdog-timer ) ;

(define-spi-serial-port ) ;

(define-jtag-interface ) ; page 48

(define-sleep-modes (idle power-down power-save adc-noise-reduction standby extended-standby)) ;; TODO page 44

(define-reset) ; page 49

(define-qtouch-library ) ;;

 ;; page 59
(define-interrupt-vector #x0000 reset)
(define-interrupt-vector #x0002 int0)

(define-interrupt-vectors
    (reset
     external-interrupt-0
     external-interrupt-1
     external-interrupt-2
     external-interrupt-3
     external-interrupt-4
     external-interrupt-5
     external-interrupt-6
     external-interrupt-7
     timer-2-compare-match
     timer-2-overflow
     timer-1-capture-event
     timer-1-compare-match-a
     timer-1-compare-match-b
     timer-1-overflow
     timer-0-compare-match
     timer-0-overflow
     serial-transfer-complete
     usart-0-receive-complete
     usart-0-data-register-empty
     usart-0-transfer-complete
     adc-conversion-complete
     eeprom-ready
     analog-comparator
     timer-1-compare-match-c
    ;; ...


;; external interrupts page 89

;; a-bit timer with pwm and asynchronous operation page 92

;; output compare modulator page 160

;; serial peripheral interface p 162

;; usart page 170

;; two-wire serial interface page 197

;; analog comparator page 227

;; analog to digital converter page 230

;; jtag interface and on-chip debug system page 246

;; boot loader support - read-while-write self-programming page 273

;; parallel programming page 290

|#
