Principles

* Racket-like just more extensible at the low level
* First implement an assembler that's platform independent (IL)
* Implement optimizations and proofs on top of it
* Convert to functional programming style as much as possible
* Build a language on top of it (with possibility for everyone to build their own)
* Proof assembly (I think this isn't really possible with modern cpus because of timing attacks and other even more complicated things, but try as much as possible)

* Convention over configuration
